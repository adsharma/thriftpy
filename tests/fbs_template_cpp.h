// automatically generated by the FlatBuffers compiler, do not modify

#pragma once
#include "flatbuffers/flatbuffers.h"
#include "flatbuffers/kvstore_builder.h"

namespace {{namespace}} {

{% for item in __fbs_meta__['tables'] %}
{% set table_name = item.__name__ %}

struct {{table_name}};
struct {{table_name}}T;

struct {{table_name}}T : public flatbuffers::NativeTable {
{% for member, type in item['_fspec'].items() %}
{% set cpp_type = cpp_types[type[1]] %}
  {{cpp_type}} {{member}};
{% endfor %}
};

struct {{table_name}} FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    {% set i = 4 %}
    {% for member, type in item['_fspec'].items() %}
    {% set MEMBER = member.upper() %}
    VT_{{MEMBER}} = {{i}},
    {% set i = i + 2 %}
    {% endfor %}
  };

  {% for member, type in item['_fspec'].items() %}
  {% set cpp_type = cpp_types[type[1]] %}
  {% set MEMBER = member.upper() %}
  {% if (cpp_type != 'std::string') %}
  {{cpp_type}} {{member}}() const { return GetField<{{cpp_type}}>(VT_{{MEMBER}}, 0); }
  bool mutate_{{member}}({{cpp_type}} _{{member}}) { return SetField<{{cpp_type}}>(VT_{{MEMBER}}, _{{member}}); }
  {% else %}
  const flatbuffers::IString *{{member}}() const { return reinterpret_cast<const flatbuffers::IString *>(GetAddressOf(VT_{{MEMBER}})); }
  flatbuffers::IString *mutable_{{member}}() { return reinterpret_cast<flatbuffers::IString *>(GetAddressOf(VT_{{MEMBER}})); }
  {% endif %}
  {% endfor %}

  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
     {% for member, type in item['_fspec'].items() %}
       {% set cpp_type = cpp_types[type[1]] %}
       {% set MEMBER = member.upper() %}
           VerifyField<{{cpp_type}}>(verifier, VT_{{MEMBER}}) &&
     {% endfor %}
           verifier.EndTable();
  }
  void ByteOrderFields() {
     {% for member, type in item['_fspec'].items() %}
       {% set cpp_type = cpp_types[type[1]] %}
       {% set MEMBER = member.upper() %}
       {% set key = 'key' in type[2] and (cpp_type != 'std::string') %}
       {%- if key %}
    flatbuffers::ByteOrderScalar<{{cpp_type}}>(GetAddressOf(VT_{{MEMBER}}));
       {% endif %}
     {% endfor %}
  }
  void FlatbufferOrderFields() {
     {% for member, type in item['_fspec'].items() %}
       {% set cpp_type = cpp_types[type[1]] %}
       {% set MEMBER = member.upper() %}
       {% set key = 'key' in type[2] and (cpp_type != 'std::string') %}
       {%- if key %}
    flatbuffers::FlatbufferOrderScalar<{{cpp_type}}>(GetAddressOf(VT_{{MEMBER}}));
       {% endif %}
     {% endfor %}
  }
  const uint8_t *GetKey() const {
    return GetAddressOf(VT_OBJ_ID);
  }
  size_t GetKeySize() const {
    return GetAddressOf(VT_SCORE) -
      GetAddressOf(VT_OBJ_ID) +
      sizeof(double);
  }
  const uint8_t *GetValue() const {
    return GetAddressOf(VT_COUNTRY);
  }
  size_t GetValueSize() const {
    return GetAddressOf(VT_MYDATA) -
      GetAddressOf(VT_NAME) +
      sizeof(flatbuffers::String) +
      1 * sizeof(flatbuffers::String);
  }
  {{table_name}}T *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
};

struct {{table_name}}Builder {
  flatbuffers::KVStoreBuilder &fbb_;
  flatbuffers::uoffset_t start_;
     {% for member, type in item['_fspec'].items() %}
       {% set cpp_type = cpp_types[type[1]] %}
       {% set MEMBER = member.upper() %}
       {% if (cpp_type != 'std::string') %}
  void add_{{member}}({{cpp_type}} {{member}}) { fbb_.AddElement<{{cpp_type}}>({{table_name}}::VT_{{MEMBER}}, {{member}}, 0); }
       {% else %}
  void add_{{member}}(flatbuffers::Offset<flatbuffers::String> {{member}}) { fbb_.AddOffset({{table_name}}::VT_{{MEMBER}}, {{member}}); }
       {% endif %}
     {% endfor %}
  {{table_name}}Builder(flatbuffers::KVStoreBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  {{table_name}}Builder &operator=(const {{table_name}}Builder &);
  flatbuffers::Offset<{{table_name}}> Finish() {
    // FIXME
    auto o = flatbuffers::Offset<{{table_name}}>(fbb_.EndTable(start_, 6));
    fbb_.Required(o, {{table_name}}::VT_COUNTRY);  // country
    return o;
  }
};

inline flatbuffers::Offset<{{table_name}}> Create{{table_name}}(flatbuffers::KVStoreBuilder &_fbb,
  {% for member, type in item['_fspec'].items() %}
  {% set cpp_type = cpp_types[type[1]] %}
  {% set delim = ',' %}
  {% if loop.last %}
  {% set delim = '' %}
  {% endif %}
  {% if (cpp_type != 'std::string') %}
    {{cpp_type}} {{member}} = 0{{delim}}
  {% else %}
    flatbuffers::Offset<flatbuffers::String> {{member}} = 0{{delim}}
  {% endif %}
  {% endfor %}
  ) {
  {{table_name}}Builder builder_(_fbb);
  {% for member, type in item['_fspec'].items() %}
  builder_.add_{{member}}({{member}});
  {% endfor %}
  return builder_.Finish();
}

inline flatbuffers::Offset<{{table_name}}> Create{{table_name}}Direct(flatbuffers::KVStoreBuilder &_fbb,
  {% for member, type in item['_fspec'].items() %}
  {% set cpp_type = cpp_types[type[1]] %}
  {% set delim = ',' %}
  {% if loop.last %}
  {% set delim = '' %}
  {% endif %}
  {% if (cpp_type != 'std::string') %}
    {{cpp_type}} {{member}} = 0{{delim}}
  {% else %}
    const char *{{member}} = nullptr{{delim}}
  {% endif %}
  {% endfor %}
  ) {
  return Create{{table_name}}(_fbb,
  {% for member, type in item['_fspec'].items() %}
  {% set cpp_type = cpp_types[type[1]] %}
  {% set delim = ',' %}
  {% if loop.last %}
  {% set delim = '' %}
  {% endif %}
  {% if (cpp_type != 'std::string') %}
    {{member}}{{delim}}
  {% else %}
    {{member}} ? _fbb.CreateString({{member}}) : 0{{delim}}
  {% endif %}
  {% endfor %}
  );
}

inline flatbuffers::Offset<{{table_name}}> Create{{table_name}}(flatbuffers::KVStoreBuilder &_fbb, const {{table_name}}T *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

inline {{table_name}}T *{{table_name}}::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void) resolver;
  auto _o = new {{table_name}}T();
  {% for member, type in item['_fspec'].items() %}
  {% set cpp_type = cpp_types[type[1]] %}
  {% if (cpp_type != 'std::string') %}
  { auto _e = {{member}}(); _o->{{member}}= _e; };
  {% else %}
  { auto _e = {{member}}(); if (_e) _o->{{member}}= _e->str(); };
  {% endif %}
  {% endfor %}
  return _o;
}

inline flatbuffers::Offset<{{table_name}}> Create{{table_name}}(flatbuffers::KVStoreBuilder &_fbb, const {{table_name}}T *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void) rehasher;
  return Create{{table_name}}(_fbb,
  {% for member, type in item['_fspec'].items() %}
  {% set cpp_type = cpp_types[type[1]] %}
  {% set delim = ',' %}
  {% if loop.last %}
  {% set delim = '' %}
  {% endif %}
  {% set key = 'key' in type[2] and (cpp_type != 'std::string') %}
  {% if (cpp_type != 'std::string') %}
    _o->{{member}}{{delim}}
  {% else %}
    {% if key %}
    _fbb.CreateString(_o->{{member}}){{delim}}
    {% else %}
    _o->{{member}}.size() ? _fbb.CreateString(_o->{{member}}) : 0{{delim}}
    {% endif %}
  {% endif %}
  {% endfor %}
  );
}

inline const {{table_name}} *Get{{table_name}}(const void *buf) { return flatbuffers::GetRoot<{{table_name}}>(buf); }

inline {{table_name}} *GetMutable{{table_name}}(void *buf) { return flatbuffers::GetMutableRoot<{{table_name}}>(buf); }

inline bool Verify{{table_name}}Buffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<{{table_name}}>(nullptr); }

inline void Finish{{table_name}}Buffer(flatbuffers::KVStoreBuilder &fbb, flatbuffers::Offset<{{table_name}}> root) { fbb.Finish(root); }

{% endfor %}

}  // namespace {{namespace}}

